Vector3f Scene::shade(const Intersection& hit, const Ray& wo) const{
    //1)对光源采样,随机获得一条入射光线
    Intersection il;
    float il_pdf;
    sampleLight(il, il_pdf);
    Vector3f incidentVec = hit.coords - il.coords;
    //2)遮挡检测
    Vector3f l_dir(0,0,0);
    Intersection testI = intersect(Ray(hit.coords, -incidentVec, 0));
   
    if (testI.happened == false || testI.m->hasEmission()) {
        //3)立体角->面积微元
        float dist2 = pow(incidentVec.norm(), 2);
        incidentVec = incidentVec.normalized();
        float cos_theta1 = dotProduct(incidentVec, il.normal.normalized());
        float cos_theta = dotProduct(-incidentVec, hit.normal.normalized());

        //4)计算直接光照
        Vector3f fr = hit.m->eval(incidentVec, wo.direction, hit.normal);
        l_dir = il.emit * fr * cos_theta * cos_theta1 / dist2;
        l_dir = l_dir / il_pdf;
    }

    //5)计算间接光照
    Vector3f l_indir(0, 0, 0);
    if (get_random_float() <= RussianRoulette) {
        Vector3f indir_incident;
        indir_incident = hit.m->sample(indir_incident, hit.normal);
        Intersection nextI = intersect(Ray(hit.coords, indir_incident));
        if (nextI.happened && nextI.m->hasEmission() == false) {
            Vector3f li = shade(nextI, Ray(hit.coords, -indir_incident));
            Vector3f fr = hit.m->eval(indir_incident, wo.direction, hit.normal);
            //theta
            float theta = dotProduct(indir_incident, hit.normal);
            float obj_pdf = hit.m->pdf(indir_incident, wo.direction, hit.normal);
            l_indir = li * fr * theta / obj_pdf;
        }
    }
    return l_dir + l_indir / RussianRoulette;
}


// Implementation of Path Tracing
Vector3f Scene::castRay(const Ray &ray, int depth) const
{
    // TO DO Implement Path Tracing Algorithm here
    Intersection hit;
    if (!(hit = intersect(ray)).happened) {
        return backgroundColor;
    }
    return shade(hit, ray);
}